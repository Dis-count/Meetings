将所有 items/groups 从大到小 排列

这个时候 最大的背包 在这些items上装

删除 装进背包中的 items

在剩下的(items)中装下一个背包

和 greedy 的比较: 注意这里第一个背包会得到最大的占比,这必然导致 其他的背包占比变小.

而 greedy 虽然不会得到某个背包最大, 但得到的解更加均匀.

************************************
可以利用  greedy  拆分为  多次连续的  单背包问题

************************************
可以认为 planning 是item分配 bag 的过程,  scheduling 是 item 在背包中的过程

我们暂时不考虑 scheduling 中排列的问题, 在24h 均匀分布即可.

*******************************************
算法流程 是: 给定 item i \in N
价值 w_i = (s_i * p_i)  max \sum_i (x_i * w_i)
规模 s_i
注意这里需要考虑: 物品的时间属性可能一样,但是价值属性不一样. 还是属于 0-1 背包
可变容量 C 实际上是时间
先得到一个 C 的下界 可以容纳所有的 items
利用二分得到 临界值C^* 精确至 0.5h
将 C^* 等比放缩至 24h 即可

返回 最小的占比 与 精确计算 进行比较.
可以预见到的是有些gap是源于 存在最优解 有些背包中 延展到了24h 而有些则占用时间较少.这显然不是等比放缩可以达到的结果.

后续可以考虑能不能在最终的可行解中进行交换以得到最优解, 最优解的判定条件是什么?

状态转移方程:
“状态”对应的“值”即为背包容量为j时，求前i个物品所能达到最大价值，设为dp[i][j]
dp[i][j] = max{dp[i-1][j-list[i].w] + v, dp[i-1][j]}

完成整个程序测试
